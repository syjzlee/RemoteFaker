<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [操作系统篇](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87)
  - [进程与线程区别](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB)
  - [谈谈多线程并发](#%E8%B0%88%E8%B0%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91)
  - [线程同步方式(Python代码实现)](#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8Fpython%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
  - [线程状态切换](#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2)
  - [分页机制](#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6)
  - [分页和分段有什么区别（内存管理）](#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)
  - [什么是虚拟内存？](#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
  - [颠簸(抖动)](#%E9%A2%A0%E7%B0%B8%E6%8A%96%E5%8A%A8)
  - [进程调度算法](#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)
  - [经典进程同步问题](#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98)
  - [进程的状态转换](#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2)
  - [进程间通信方式](#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F)
  - [僵尸进程和孤儿进程](#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B)
  - [fork进程](#fork%E8%BF%9B%E7%A8%8B)
  - [Socket编程](#socket%E7%BC%96%E7%A8%8B)
  - [Linux的五种IO模型](#linux%E7%9A%84%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B)
  - [IO 多路复用模型](#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B)
    - [select](#select)
    - [poll](#poll)
    - [epoll](#epoll)
    - [select、poll、epoll区别](#selectpollepoll%E5%8C%BA%E5%88%AB)
  - [谈谈死锁](#%E8%B0%88%E8%B0%88%E6%AD%BB%E9%94%81)
    - [死锁的概念　　　](#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5)
    - [死锁产生的原因](#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0)
    - [死锁产生的四个必要条件](#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6)
    - [解决死锁的基本方法](#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 操作系统篇
* 学习资料推荐
   - [哈工大李治军老师的OS](https://www.icourse163.org/course/HIT-1002531008)
    - [配套的实验环境](https://www.shiyanlou.com/courses/115)
    - [gitbook和源码](https://github.com/hoverwinter/HIT-OSLab)
    - [Linux内核完全注释](https://book.douban.com/subject/1231236/)
## 进程与线程区别
* 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。
* 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；进程在执行过程中拥有独立的内存单元，而多个线程线程是共同享有进程占有的资源和地址空间的(*线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID*)。**进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。**
## 谈谈多线程并发
* 将程序的执行逻辑与调度机制的细节，交替执行的操作，异步 I/O 以及资源等待等问题分离开来。通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。 
* 提高资源利用率，多处理器系统的出现，使得同一个程序的多个线程可以被同时调度到多个 CPU 上运行。因此，多线程程序可以通过提高处理器资源的利用率来提升系统的吞吐率。当然多线程程序也有助于在单处理器系统上获得更高的吞吐率（如果程序的一个线程在等待 I/O 操作）
* 多线程的性能不一定优于单线程，对于单核CPU，如果是 CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用 CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。但是对于 IO密集型任务，肯定是需要使用多线程的。而对于多核CPU，对于解压文件来说，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。
* 使用 queue 进行线程通信。当线程之间如果要共享资源或数据的时候，可能变的非常复杂。Python的threading模块提供了很多同步原语，包括信号量，条件变量，事件和锁。如果可以使用这些原语的话，应该优先考虑使用这些，而不是使用queue（队列）模块。队列操作起来更容易，也使多线程编程更安全，因为队列可以将资源的使用通过单线程进行完全控制，并且允许使用更加整洁和可读性更高的设计模式。
```python
import threading
import time
class GetHtml(threading.Thread):
    def __init__(self,name):
        super().__init__(name=name)
    def run(self):
        print('get html start')
        time.sleep(2)
        print('get html end')
class GetUrl(threading.Thread):
    def __init__(self,name):
        super().__init__(name=name)
    def run(self):
        print('get url start')
        time.sleep(4)
        print('get url end')
if __name__ == "__main__":
    thread1=GetHtml(name='html')
    thread2=GetUrl(name='url')
    start_time=time.time()
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    end_time=time.time()
    total_time=end_time-start_time
    print('total running tim:{}'.format(total_time))
```
## 线程同步方式([Python代码实现](https://github.com/MorsoLi/python-interview-guide/tree/master/thread-parallel))
* 主要参考
    - [四种线程同步（或互斥）方式小结](https://blog.csdn.net/ebowtang/article/details/29905309)
* 线程同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！
* 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。
    * **互斥量 Mutex**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源。(RLock 和 Lock)
    * **信号量 Semaphare**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过Release将当前可用资源计数加1，在任何时候当前可用资源计数决不可能大于最大资源计数。
    * **事件对象 Event**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。
## 线程状态切换
![thread-status-change.png](https://i.loli.net/2019/08/18/g6zZDk5iLaYCMcR.png)
## 分页机制
* 主要参考
    - [分页机制图文详解](https://www.jianshu.com/p/3558942fe14f)
* 一级页表的弊端：
    - 每存取一个数据，需两次访问内存，第一次访问内存中的页表，第二次访问内存中的数据，效率较低。改进：增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想寄存器”或“快表”，IBM中称为TLB，用于存放当前访问的那些页表项。
    - IA-32体系结构中，处理器为32位，可寻址 2^32 =4GB的虚拟地址空间，若每页大小为4KB，则共分为4GB/4KB= 2^20 =1048576页，因此页表中应有1048576项，每个页表项为4B，则一个页表需要4MB的连续的物理内存，每个进程都需要自身的页表占4MB，将导致大量内存用于保存进程的页表。
    - 改进：采用两级页表，每页中存2^10 项，共分为2^10 页，并新增一个页目录表来记录这 2^10 页表的地址与信息，因此页目录表大小为2^10*4B=4KB放在内存中，需要具体的表再由此读入。采用离散分配方式代替原来页表需要的连续物理内存，将当前需要的部分页表项调入内存，其余页表项仍驻留在磁盘上，需要时再调入。
## 分页和分段有什么区别（内存管理）
* 主要参考
    - [分段和分页内存管理](https://blog.csdn.net/bupt_tinyfisher/article/details/8939689)
* 段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如 4k 的段换5k 的段，会产生 1k 的外碎片）
* 页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）
* 两者的不同点：
    - 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
    - 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；
    - 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
    - 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
    - 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如 4k 的段换 5k 的段，会产生1k 的外碎片）。
## 什么是虚拟内存？
* 主要参考
    - [BAT面试之操作系统内存详解](http://www.imooc.com/article/11015)
* 内存的发展历程：没有内存抽象 (单进程，除去操作系统所用的内存之外，全部给用户程序使用) —> 有内存抽象（多进程，进程独立的地址空间，交换技术 (内存大小不可能容纳下所有并发执行的进程)）—> 连续内存分配 (固定大小分区 (多道程序的程度受限)，可变分区 (首次适应，最佳适应，最差适应)，碎片) —> 不连续内存分配（分段，分页，段页式，虚拟内存）。
* 虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页 (Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块 (称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。
* 局部性原理
    - 时间上的局部性：最近被访问的页在不久的将来还会被访问；
    - 空间上的局部性：内存中被访问的页周围的页也很可能被访问。
* 页面置换算法
    - FIFO 先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
    - LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
    - LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
    - OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。
* 虚拟内存的应用与优点：虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用。虚拟内存的使用可以带来以下好处：
    - 在内存中可以保留多个进程，系统并发度提高
    - 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大
## 颠簸(抖动)
* 颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。
* 内存颠簸的解决策略包括：
    - 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；
    - 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；
## 进程调度算法
* FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU
* SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度
* 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；
* 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
* 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
* 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
## 经典进程同步问题
* 主要参考
    - [进程同步的基本概念](https://www.kancloud.cn/hanghanghang/os/116760)
* 信号量（PV操作）、管程
## 进程的状态转换
* 主要参考
    - [操作系统之进程的状态和转换详解](https://blog.csdn.net/qwe6112071/article/details/70473905)
* 进程的三种状态情况：运行态（占用CPU）;就绪态（可运行，但暂时没有CPU分配给它）；阻塞态(除非某种外部条件发生，就算CPU空闲，也不能执行)。unix用block阻塞。状态转换表
* 就绪状态 ：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。
* 执行状态：当一个进程在处理机上运行时，则称该进程处于运行状态。
* 阻塞状态：一个进程正在等待某一事件发生（例如请求I／O而等待I／O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。
## 进程间通信方式
* 主要参考
    * [进程间通信（IPC）介绍](https://www.cnblogs.com/CheeseZH/p/5264465.html)
* 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。进程间通信（Inter-Process Communication）方式：管道（匿名管道/命名管道），消息队列，**共享内存、信号量、套接字（socket），后三种较常用**
    * **管道**一般指匿名管道，是 UNIX 系统IPC最古老的形式,只能用于具有亲缘关系的进程之间的通信（父子进程或者兄弟进程之间），是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存。**命名管道（FIFO）**除了具有匿名管道所具有的功能外，它还允许无亲缘关系进程间的通信。
    * **消息队列**是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
    * **共享内存**可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。特点:共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
    * **信号量**主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。特点：信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。[信号量基于操作系统的 PV 操作](https://blog.csdn.net/u014495460/article/details/82883282)，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。支持信号量组。
    * **套接字**，这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
## [僵尸进程和孤儿进程](https://www.cnblogs.com/Anker/p/3271773.html#3777880)
* 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
* 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
## [fork进程](https://blog.csdn.net/u013851082/article/details/76902046)
* 由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。
* fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置。
## Socket编程
* [Socket Programming in Python (Guide)](https://realpython.com/python-sockets/)
![20190507170534122.png](https://i.loli.net/2019/08/13/e1MknSJRAbXI3du.png)
## Linux的五种IO模型
* 主要参考
    * [聊聊IO多路复用之select、poll、epoll详解](https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666538922&idx=1&sn=e6b436efd6a4f53dcbf20f4ce11a986a&scene=23&srcid=0425xFfzV9LmmVrdeEQ4He1W#rd)
    * [漫话：如何给女朋友解释什么是Linux的五种IO模型](https://juejin.im/post/5b94e93b5188255c672e901e#comment)

* 在Linux(UNIX)操作系统中，共有五种IO模型，分别是：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型以及异步IO模型。 I/O操作，以一次磁盘文件读取为例，读取的文件是存储在磁盘上的，我们的目的是把它读取到内存中，可以把这个步骤简化成（真正的文件读取还涉及到缓存等细节）把数据从硬件（硬盘）中读取到用户空间中。关于用户空间、内核空间以及硬件等的关系如可以通过钓鱼的例子理解。鱼塘就可以映射成磁盘，中间过渡的鱼钩可以映射成内核空间，最终放鱼的鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。
1. **阻塞IO模型**。应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。（并发低，时效性要求低）
![utf-8165bde9e5723181b.jpg](https://i.loli.net/2019/08/16/PbuHlOjvmwNdTV4.jpg)
2. **非阻塞IO模型**。应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。
![65bde9e699d0713.jpg](https://i.loli.net/2019/08/16/48SqhVp672HUZG3.jpg)
3. **IO多路复用模型**。IO多路转接是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。PS: 这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。
![165bde9e6e6da275.jpg](https://i.loli.net/2019/08/16/MFGRjAe8ontQ2U1.jpg)
4. **信号驱动IO模型**。应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。PS: 这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。
![ut165bde9e6c6552e2.jpg](https://i.loli.net/2019/08/16/7hV4NISfOwTktWE.jpg)
5. **异步IO模型**。用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。(应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。)
![](https://i.imgsafe.org/60/6095077381.jpeg)
* 五种IO模型比较:以上前四种都是同步的IO模型。因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。信号驱动难道不是异步的么？ 信号驱动，内核是在数据准备好之后通知进程，然后进程再通过recvfrom操作进行数据拷贝。我们可以认为数据准备阶段是异步的，但是，数据拷贝操作是同步的。所以，整个IO过程也不能认为是异步的。
![](https://i.imgsafe.org/60/609e06b39f.jpeg)
## IO 多路复用模型
* I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O(epoll是Linux所特有，而select则应该是POSIX所规定的)，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
* IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：
    1. 当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。
    2. 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
    3. 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用
    4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
    5.  如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。
* [用Python实现多用户/多服务器模型](https://github.com/MorsoLi/python-interview-guide/tree/master/server-program)
### select
* select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。
### poll
* poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。
### epoll
* epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。
### select、poll、epoll区别
* 支持一个进程所能打开的最大连接数
![Snipaste_2019-05-29_10-08-08.png](https://i.loli.net/2019/08/16/YDrUzSZBdHOCFeN.png)
* FD剧增后带来的IO效率问题
![Snipaste_2019-05-29_10-08-18.png](https://i.loli.net/2019/08/16/jdLBwPryzn5Mp2W.png)
* 消息传递方式
![Snipaste_2019-05-29_10-08-28.png](https://i.loli.net/2019/08/16/koPVBeFp1XIYGfS.png)
* 最佳实践：并发性不高但连接活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调；并发性高但连接不活跃情况下，epoll的性能更好，select低效是因为每次它都需要轮询。
## 谈谈死锁
### 死锁的概念　　　
* 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。
### 死锁产生的原因
* 系统中的资源可以分为两类：
* 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
* 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
* 产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
* 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁。
### 死锁产生的四个必要条件
* 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
* 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
* 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
* 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系
### 解决死锁的基本方法
* 解决死锁的基本方法主要有 预防死锁、避免死锁、解除死锁
* **预防死锁**的基本思想是 只要**确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生**，具体方法包括：
    * 打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。
    * 打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。
    * 打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。
    * 打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。
* **避免死锁**的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。
* **解除死锁**
    * 终止进程（简单粗暴），就是字面上的，你们死锁了，我就把你们一起杀掉，缺点就是如果一个进程跑了很长时间，但是被杀了，还得从头来。
    * 逐个终止进程，按照某种顺序，挨个杀死进程，每杀一个进程就去看看死锁解除了没有（每杀一个进程都会释放一些资源，如果释放好粗来的资源解决了死锁问题，就没必要再滥杀无辜了），没解除就继续杀。