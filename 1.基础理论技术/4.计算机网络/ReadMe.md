<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [计算机网络篇](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87)
  - [计算机网络概述](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0)
  - [从URL输入到页面展现到底发生什么？](#%E4%BB%8Eurl%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)
  - [ARP 协议工作原理](#arp-%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [TCP 三次握手](#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
  - [TCP 四次挥手](#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
  - [TCP 怎样保证可靠性](#tcp-%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7)
  - [流量控制和拥塞控制](#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
  - [TCP 与 UDP 的区别](#tcp-%E4%B8%8E-udp-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [HTTP协议](#http%E5%8D%8F%E8%AE%AE)
    - [HTTP 和 HTTPS 的区别](#http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [URL详解](#url%E8%AF%A6%E8%A7%A3)
  - [HTTP 常见方法（GET/PUT）](#http-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95getput)
    - [安全性和幂等性](#%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E5%B9%82%E7%AD%89%E6%80%A7)
    - [GET和POST 区别](#get%E5%92%8Cpost-%E5%8C%BA%E5%88%AB)
  - [常见 HTTP 状态码](#%E5%B8%B8%E8%A7%81-http-%E7%8A%B6%E6%80%81%E7%A0%81)
  - [HTTP 长连接与短连接](#http-%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5)
    - [长连接](#%E9%95%BF%E8%BF%9E%E6%8E%A5)
    - [短连接](#%E7%9F%AD%E8%BF%9E%E6%8E%A5)
  - [cookie 和 session 的区别](#cookie-%E5%92%8C-session-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [JSON Web Token](#json-web-token)
  - [IP 地址的分类](#ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB)
  - [OSI七层参考模型](#osi%E4%B8%83%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 计算机网络篇
* 主要参考
    - [协议森林](https://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html)
    - [HTTP协议详解](https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html)
## [计算机网络概述](./计算机网络概述.md)
## [从URL输入到页面展现到底发生什么？](https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247483803&idx=1&sn=460597ae3bd3ec10ad3426b7db605074&chksm=c066800df711091b2b6e005a922fff4a6a8e4b7930928a1c60fc0ac657c3ea5061cf1b51563d&mpshare=1&scene=1&srcid=#rd)
* DNS查询，ARP解析，TCP三次握手连接，HTTP请求，反向代理Nginx，uwsgi/gunicorn（WSGI服务器）,服务器响应，浏览器页面渲染，TCP四次挥手。
## ARP 协议工作原理
* 网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。
## TCP 三次握手
* 重点记住每个阶段以后客户和服务器的状态变化
![20180717202520531.png](https://i.loli.net/2019/08/15/xpwUj2QYqrEz5a3.png)
* 为什么不能用两次握手进行连接？
答：为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达 Server。这是，Server 误以为这是 Client 发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用 “三次握手”，那么只要 Server 发出确认数据包，新的链接就建立了。由于 client 此时并未发出建立链接的请求，所以其不会理睬 Server 的确认，也不与 Server通信；而这时 Server 一直在等待 Client 的请求，这样Server 就白白浪费了一定的资源。若采用 “三次握手”，在这种情况下，由于 Server 端没有收到来自客户端的确认，则就会知道 Client 并没有要求建立请求，就不会建立链接。
## TCP 四次挥手
![20180717204202563.png](https://i.loli.net/2019/08/15/yqCMJ3jxzErW4it.png)
* 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
## TCP 怎样保证可靠性
* 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；
* 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
* 丢弃重复数据：对于重复数据，能够丢弃重复数据；
* 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
* 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
* 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。
## 流量控制和拥塞控制
* 主要参考
    * [TCP的流量控制和拥塞控制](https://blog.csdn.net/yechaodechuntian/article/details/25429143)
* 区别注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。
    - 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：慢开始、拥塞避免；快重传、快恢复。
    - 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。
## TCP 与 UDP 的区别
* TCP 是面向连接的，UDP 是无连接的；
* TCP 是可靠的，UDP 是不可靠的；
* TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多的通信模式；
* TCP 是面向字节流的，UDP 是面向报文的；
* TCP 有拥塞控制机制; UDP 没有拥塞控制，适合媒体通信；
* TCP 首部开销 (20 个字节) 比 UDP 的首部开销 (8 个字节) 要大
## HTTP协议
* 超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器，目前我们使用的是HTTP/1.1 版本。
* HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制和session机制来维护状态。
* HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。
### HTTP 和 HTTPS 的区别
1. https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
### URL详解
* URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下：
```
schema://host[:port#]/path/.../[?query-string][#anchor]
>schema               指定低层使用的协议(例如：http, https,ftp)
host                   HTTP服务器的IP地址或者域名
port#         HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明
path                 访问资源的路径
query-string       发送给http服务器的数据
anchor             锚
```
## HTTP 常见方法（GET/PUT）
* Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 
### 安全性和幂等性
* 安全意味着该操作用于获取信息而非修改信息。幂等意味着对同一 URL 的多个请求应该返回同样的结果。
![Snipaste_2019-05-09_08-39-20.png](https://i.loli.net/2019/08/13/Z74rHxcqbkM93A8.png)
### GET和POST 区别
* 最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.
* GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.
* GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
* GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。
## 常见 HTTP 状态码
* Response 消息中的第一行叫做状态行，由HTTP协议版本号，状态码，状态消息三部分组成。状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response。HTTP/1.1中定义了5类状态码，状态码由三位数字组成，第一个数字定义了响应的类别
    ```
    1XX  提示信息 - 表示请求已被成功接收，继续处理
    2XX  成功 - 表示请求已被成功接收，理解，接受
        200 OK :  表明该请求被成功地完成，所请求的资源发送回客户端
    3XX  重定向 - 要完成请求必须进行更进一步的处理
        302 Found :  重定向，新的URL会在response 中的Location中返回，浏览器将会
        自动使用新的URL发出新的Request
        304 Not Modified :  代表上次的文档已经被缓存了， 还可以继续使用
        （提示：如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面）
    4XX  客户端错误 -  请求有语法错误或请求无法实现
        400 Bad Request ： 客户端请求与语法错误，不能被服务器所理解
        403 Forbidden :  服务器收到请求，但是拒绝提供服务
        404 Not Found : 请求资源不存在（还有可能是输错了URL)
    5XX  服务器端错误 -   服务器未能实现合法的请求
        500 Internal Server Error:服务器发生了不可预期的错误
        503 Server Unavailable:服务器当前不能处理客户端的请求，一段时间后可能恢复正常
    ```
## HTTP 长连接与短连接
### 长连接
* **长连接定义**：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于P2P点对点的通信。长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接
* **长连接适用场景**：以下这些连接，如果每次操作都要建立连接然后再操作的话处理速度会降低。所以操作时第一次连接上以后，以后每次直接发送数据就可以了，不用再建立TCP连接。常连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。
    * 即时通信系统：其它用户登录、发送信息；
    * 即时报价系统：后台数据库内容发生变化；
    * 数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，频繁的socket创建也是对资源的浪费。
### 短连接
* **短连接定义**: Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。短连接的操作步骤是：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
* **短连接的适用场景**：每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。 
## cookie 和 session 的区别
* 会话状态保存在客户端。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个 Cookie，而客户端浏览器会把Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie 的内容。
* 会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取 Session 来保存状态，这时，如果服务器已经为此客户端创建过 session，服务器就按照 sessionid 把这个 session 检索出来使用；如果客户端请求不包含 sessionid，则为此客户端创建一个session 并且生成一个与此 session 相关联的 sessionid，并将这个 sessionid 在本次响应中返回给客户端保存。保存这个 sessionid 的方式可以采用 cookie 机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用 Cookie 的话，可以通过 URL 重写机制将sessionid 传回服务器。
* 实现机制：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；
* 安全性：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；
* 大小限制：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；
* 服务器资源消耗：Session 是保存在服务器端上会存在一段时间才会消失，如果 session 过多会增加服务器的压力。
## JSON Web Token
* 主要参考
    - [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)
![1821058-2e28fe6c997a60c9.png](https://i.loli.net/2019/08/25/EKdXuH2ib9gIzyn.png)
* JWT 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准，该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
## IP 地址的分类
* IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地
址。
* 每个 IP 地址包括两个标识码（ID），即网络 ID 和主机ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：
    - A 类地址：以 0 开头，第一个字节范围：0~127；
    - B 类地址：以 10 开头，第一个字节范围：128~191；
    - C 类地址：以 110 开头，第一个字节范围：192~223；
    - D 类地址：以 1110 开头，第一个字节范围为: 224~239；
    - E 类地址：以 1111 开头，保留地址
## OSI七层参考模型
![OSI网络参考模型功能表示.png](https://i.loli.net/2019/08/15/HKS5TkxRfrbMVpC.png)